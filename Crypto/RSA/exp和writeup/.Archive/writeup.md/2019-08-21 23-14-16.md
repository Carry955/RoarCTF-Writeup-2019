首先已知条件

```python
n=117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127L

e=0x10001

(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x=2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724L

p=gmpy2.next_prime(x*y*z)
q=gmpy2.next_prime(z)

c=104691362123417589582551926531991781182010115901906985242039858907478735399784169051363443219315680244232603533899657231603732323266992359436518422851277069852793135320396586515487921637920627272606974731853791181271097899570276732277312961775278934241404863519840373617638621536398209255347566027214411203044623463749518663685607627212717097166124505123129373333338412199099199928067759937853247401620571810107903873489834435586333677991755979431408011776165868218508677566291652682933956103976791630704584853343422052444254468560250747030329091301992578584871488469381826293759687914010014083275135171832587631422L

```

显然我们需要根据与xy有关的等式推算出xy的值或者具体关系
设 
```angular2
(((y%x)**5)%(x%y))**2019+y**316+(y+1)/x=A
```
$$
2^{2019}>>A
$$


所以推出                                                       
```angular2
(((y%x)**5)%(x%y))=1
or
(((y%x)**5)%(x%y))=0
```
忽略(y+1)/x先算出y的近似值
```angular2
y=gmpy2.iroot(A,316)[0]
```
y近似值为83
再回头看(y+1)/x的值不超过两位数，可忽略。
确定y的值为83，继续推导得x的值为2.


接下来看p和q

```python
p=gmpy2.next_prime(x*y*z)
q=gmpy2.next_prime(z)
```

可以得到
$$
\begin{cases}
p=x*y*z+a\\
q=z+b\\
\end{cases}
$$
已知$$n=p*q$$，又因为a，b值相对于y，x来说基本可以忽略。

那么得到     $$n\approx(x*y*z)*z$$

计算得
$$
z\approx842868045681390934539739959201847552284980179958879667933078453950968566151662147267006293571765463137270594151138695778986165111380428806545593588078365331313084230014618714412959584843421586674162688321942889369912392031882620994944241987153078156389470370195514285850736541078623854327959382156753458023
$$
计算得到的这个z近似值一定是大于原来的z的。但是我们不需要准确的z，我们只需要q就可以了。

进行一个爆破恢复q

```python
import gmpy2
import libnum

A=2683349182678714524247469512793476009861014781004924905484127480308161377768192868061561886577048646432382128960881487463427414176114486885830693959404989743229103516924432512724195654425703453612710310587164417035878308390676612592848750287387318129424195208623440294647817367740878211949147526287091298307480502897462279102572556822231669438279317474828479089719046386411971105448723910594710418093977044179949800373224354729179833393219827789389078869290217569511230868967647963089430594258815146362187250855166897553056073744582946148472068334167445499314471518357535261186318756327890016183228412253724L
y=gmpy2.iroot(A,316)[0]
print y
x=2
n = 117930806043507374325982291823027285148807239117987369609583515353889814856088099671454394340816761242974462268435911765045576377767711593100416932019831889059333166946263184861287975722954992219766493089630810876984781113645362450398009234556085330943125568377741065242183073882558834603430862598066786475299918395341014877416901185392905676043795425126968745185649565106322336954427505104906770493155723995382318346714944184577894150229037758434597242564815299174950147754426950251419204917376517360505024549691723683358170823416757973059354784142601436519500811159036795034676360028928301979780528294114933347127L
e = 0x10001
c = 104691362123417589582551926531991781182010115901906985242039858907478735399784169051363443219315680244232603533899657231603732323266992359436518422851277069852793135320396586515487921637920627272606974731853791181271097899570276732277312961775278934241404863519840373617638621536398209255347566027214411203044623463749518663685607627212717097166124505123129373333338412199099199928067759937853247401620571810107903873489834435586333677991755979431408011776165868218508677566291652682933956103976791630704584853343422052444254468560250747030329091301992578584871488469381826293759687914010014083275135171832587631422L
z1=gmpy2.iroot(n/x/y,2)[0]
for i in range(0,9999):
    z=gmpy2.next_prime(z1-i)
    if n%z==0:
        q=z
        p=n/q
        d=gmpy2.invert(e,(p-1)*(q-1))
        print libnum.n2s(pow(c,d,n))
        break
```

得到flag











